# -*- coding: utf-8 -*-
"""train.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vS7-v1Ww-LPeCeDRBwEGwuMFsLZD1AAW
"""

# %%capture
# from google.colab import files

# !cp -av /content/drive/MyDrive/Colab_Notebooks/images/ /content
# !cp -av /content/drive/MyDrive/Colab_Notebooks/masks/ /content

# !cp /content/drive/MyDrive/Colab_Notebooks/dataset.py /content
# !cp /content/drive/MyDrive/Colab_Notebooks/unet_model.py /content

from unet_model import UNet
import torch.optim as optim
from tqdm import tqdm

import os
import random

import numpy as np
import torch
from skimage.io import imread
from torch.utils.data import Dataset, DataLoader
import torchvision.transforms as transforms
import nibabel as nib
from glob import glob
import matplotlib.pyplot as plt
import torch.nn as nn
from aslloss import AsymmetricLossOptimized

from dataset import MRIdata
from diceloss import DiceLoss


def pix_accuracy(pred, target):
    # pred = (pred>0.5).float()
    correct = torch.sum(pred == target).item()
    total   = torch.sum(target == target).item()
    return correct / total

def mean_IOU(pred, label):
    # pred = (pred>0.5).float()
    intersect = pred + label
    intersect_area = torch.sum(intersect != 0).item()
    cross_area = torch.sum(intersect == 2).item()
    
    if torch.sum(intersect == 2) == torch.sum(label == 1):
        iou = 1
    
    elif cross_area == 0 and intersect_area == 0:
        iou = 1
    else :
        iou = cross_area / intersect_area     
    return iou

def get_lr(optimizer):
    for param_group in optimizer.param_groups:
        return param_group['lr']

def train():
  epoch = 50
  thres = 0.3
  best_acc = 0.6565
  
  for e in range(epoch):
    model.train()
    tot_loss = 0
    tot_acc = 0
    tot_iou = 0
    count = 0
    
    plot_pred = np.zeros((64,64,64))
    plot_mask = np.zeros((64,64,64))

    if e%10 == 0 and e!= 0:
      optimizer.param_groups[0]['lr'] = get_lr(optimizer) * 0.5

    print("lr : ", get_lr(optimizer))

    for c , (images, masks) in enumerate(tqdm(trainset_Loader)):
      image, mask = images.to('cuda') ,masks.to('cuda') 


      model.zero_grad()
      output = model(image)
      loss = critirion(output, mask)
      loss.backward()
      optimizer.step()


      # for idx in range(image.size()[-1]):
      #   img = image[:,idx,:,:].unsqueeze(1)
      #   msk = mask[:,idx,:,:].unsqueeze(1)
      #   model.zero_grad()
      #   output = model(img)
      #   loss = critirion(output, msk)
      #   loss.backward()
      #   optimizer.step()
          
      tot_loss += loss.item()
      tot_acc += pix_accuracy(output, mask)
      tot_iou += mean_IOU(output, mask) 
      count += 1


    print('=========================================')
    print('loss : ' + str(round(tot_loss/ count,4)))
    print('pix_acc : ' + str(round(tot_acc/ count,4)))
    print('mean IOU : ' + str(round(tot_iou/ count,4)))
    print('=========================================')

    val_acc = validation(model,valset_Loader,best_acc )
    if val_acc > best_acc:
      best_acc = val_acc
      save_path = r"u_net_slice_asl.pt"
      state = {"state_dict" : model.state_dict()}
      torch.save(state,save_path)

  return plot_pred, plot_mask

def validation(model, dataset,best_acc):
  model.eval()
  tot_acc = 0
  tot_iou = 0
  count = 0
  with torch.no_grad():
      for c , (images, masks) in enumerate(tqdm(dataset)):

        image, mask = images.to('cuda') ,masks.to('cuda') 
        output = model(image)

        tot_acc += pix_accuracy(output, mask)
        tot_iou += mean_IOU(output, mask) 
        count += 1

  print('================== validation =======================')
  print('pix_acc : ' + str(round(tot_acc/ count,4)))
  print('mean IOU : ' + str(round(tot_iou/ count,4)) + " / " + str(best_acc))
  print('================== validation =======================')

  return round(tot_iou/ count,4)


def train_slice():
  epoch = 50
  thres = 0.3
  best_acc = 0
  
  for e in range(epoch):
    model.train()
    tot_loss = 0
    tot_acc = 0
    tot_iou = 0
    count = 0
    
    plot_pred = np.zeros((64,64,64))
    plot_mask = np.zeros((64,64,64))


    optimizer.param_groups[0]['lr'] = get_lr(optimizer) * np.power(0.95,e)

    print("lr : ", get_lr(optimizer) , ' | epoch : ' , e)

    for c , (images, masks) in enumerate(tqdm(trainset_Loader)):
      image, mask = images.to('cuda') ,masks.to('cuda') 

      # image = image.permute(1,0,2,3)
      # mask = mask.permute(1,0,2,3)
      # output = model(image)
      # loss = critirion(output, mask)
      # loss.backward()
      # optimizer.step()

      for idx in range(image.size()[-1]):
        img = image[:,idx,:,:].unsqueeze(1)
        msk = mask[:,:,idx,:,:]

        model.zero_grad()
        output = model(img)
        loss = critirion(output, msk)
        loss.backward()
        optimizer.step()
          
        tot_loss += loss.item()
        tot_acc += pix_accuracy(output.max(1)[1], msk.max(1)[1])
        tot_iou += mean_IOU(output.max(1)[1], msk.max(1)[1]) 
        count += 1


    print('=========================================')
    print('loss : ' + str(round(tot_loss/ count,4)))
    print('pix_acc : ' + str(round(tot_acc/ count,4)))
    print('mean IOU : ' + str(round(tot_iou/ count,4)))
    print('=========================================')

    val_acc = validation_slice(model,valset_Loader,best_acc )
    if val_acc > best_acc:
      best_acc = val_acc
      save_path = model_name
      state = {"state_dict" : model.state_dict()}
      torch.save(state,save_path)

  return 

def validation_slice(model, dataset,best_acc):
  model.eval()
  tot_acc = 0
  tot_iou = 0
  count = 0
  with torch.no_grad():
      for c , (images, masks) in enumerate(tqdm(dataset)):

        image, mask = images.to('cuda') ,masks.to('cuda') 

        # image = image.permute(1,0,2,3)
        # mask = mask.permute(1,0,2,3)
        # output = model(image)
        
        for idx in range(image.size()[-1]):
          img = image[:,idx,:,:].unsqueeze(1)
          msk = mask[:,:,idx,:,:]

          model.zero_grad()
          output = model(img)
          tot_acc += pix_accuracy(output.max(1)[1], msk.max(1)[1])
          tot_iou += mean_IOU(output.max(1)[1], msk.max(1)[1]) 
          count += 1

  print('================== validation =======================')
  print('pix_acc : ' + str(round(tot_acc/ count,4)))
  print('mean IOU : ' + str(round(tot_iou/ count,4)) + " / " + str(best_acc))
  print('================== validation =======================')

  return round(tot_iou/ count,4)


if __name__ == "__main__":

  model_name = "u_net_2d_slice_asl.pt"

  dataset = MRIdata(onehot = True) 

  trainset, valset = torch.utils.data.random_split(dataset, [int(len(dataset)*0.9), len(dataset) - int(len(dataset)*0.9)])
  trainset_Loader = DataLoader(trainset, batch_size = 4, shuffle = True)
  valset_Loader = DataLoader(valset, batch_size = 64, shuffle = True)
  # image , mask = next(iter(trainset_Loader))
  # model = UNet(in_channels=64, out_channels = 64, init_features=128).to("cuda") # for 3d input
  model = UNet(in_channels=1, out_channels = 2).to("cuda")  # for 2d slice input
  if os.path.exists(model_name):
      checkpoint = torch.load(model_name)
      model.load_state_dict(checkpoint['state_dict'])
      print("model loaded")

  # critirion = DiceLoss()
  critirion = AsymmetricLossOptimized()
  # critirion = nn.BCELoss()
  optimizer = optim.Adam(model.parameters(), lr = 0.01 ,weight_decay = 1e-5)

  # plot_pred, plot_mask = train()
train_slice()


